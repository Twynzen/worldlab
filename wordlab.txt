
Arquitectura y Especificaciones para un Monorepo de Motor de Juego Modular: @worldlab


I. Arquitectura Fundamental del Monorepo para @worldlab

La base de cualquier sistema de software escalable y mantenible reside en su arquitectura de repositorio y herramientas. Para el ecosistema @worldlab, se propone una arquitectura de monorepo moderna, optimizada para el rendimiento del desarrollador, la velocidad de integración continua (CI) y la coherencia del código. Esta sección detalla la selección de herramientas, la configuración del espacio de trabajo y las estrategias para garantizar la calidad en todo el proyecto.

1.1. Selección y Justificación de las Herramientas del Monorepo

El panorama de las herramientas de monorepo para TypeScript/JavaScript está dominado por varias soluciones clave, cada una con sus propias fortalezas y filosofías. Una evaluación cuidadosa es fundamental para seleccionar la pila que mejor se alinee con los objetivos de un motor de juego modular como @worldlab.

1.1.1. Análisis del Ecosistema de Herramientas

Las principales herramientas consideradas son Lerna, Nx y Turborepo.
Lerna: Históricamente una de las herramientas más populares, Lerna se destaca en la gestión de versiones y la publicación de paquetes múltiples. Sin embargo, carece de mecanismos avanzados de almacenamiento en caché y optimización de compilación inherentes a las soluciones más modernas.1
Nx: Más que una simple herramienta de gestión, Nx es un sistema de compilación completo ("build system") que ofrece características avanzadas como la generación de código, la visualización del grafo de dependencias y un rico ecosistema de plugins. Su enfoque es potente pero también prescriptivo, introduciendo conceptos propios que conllevan una curva de aprendizaje de moderada a pronunciada.1 Es importante destacar que Lerna ha sido adquirido por Nrwl (la empresa detrás de Nx) y ahora utiliza el ejecutor de tareas de Nx internamente, lo que indica una convergencia de la industria hacia sistemas de compilación más potentes.3
Turborepo: Escrito en Rust, Turborepo se posiciona como un sistema de compilación de alto rendimiento centrado en la velocidad. Logra esto a través de un almacenamiento en caché inteligente y una ejecución paralela de tareas. Su filosofía es aumentar, en lugar de reemplazar, las herramientas existentes como Yarn o NPM Workspaces, ofreciendo mejoras de rendimiento significativas con una configuración mínima y una curva de aprendizaje baja.1

1.1.2. Recomendación Estratégica: Turborepo y Yarn Workspaces

Para el monorepo @worldlab, se recomienda una combinación de Yarn Workspaces para la gestión de dependencias y Turborepo para la orquestación de tareas y la optimización de la compilación.
Esta elección se basa en una relación simbiótica clave: Yarn Workspaces es el primitivo de bajo nivel que gestiona el "hoisting" de dependencias y el enlace simbólico de paquetes locales, resolviendo eficazmente el problema de compartir código entre paquetes.4 Sin embargo, el verdadero potencial de rendimiento de un monorepo se desbloquea al superponer un sistema de compilación inteligente. Turborepo aprovecha el grafo de dependencias definido implícitamente por las configuraciones del espacio de trabajo para realizar su almacenamiento en caché y ejecución paralela. No reemplaza al gestor de paquetes; es un orquestador de alto nivel que consume la estructura proporcionada por Yarn para ofrecer ganancias de rendimiento exponenciales.
Esta combinación proporciona el equilibrio ideal para un motor de juego fundamental:
Rendimiento: La compilación en caché de Turborepo reduce drásticamente los tiempos de compilación locales y de CI, un factor crítico para la productividad del desarrollador.2
Simplicidad: La configuración es mínima y la curva de aprendizaje es baja, lo que permite al equipo centrarse en la lógica del motor en lugar de en la complejidad de las herramientas.1
Flexibilidad: No impone una estructura de aplicación rígida, lo que es ideal para construir bibliotecas de motor reutilizables.
La siguiente tabla resume el análisis comparativo que fundamenta esta decisión.
Tabla 1: Análisis Comparativo de Herramientas de Monorepo
Característica
Lerna
Nx
Turborepo
Funcionalidad Principal
Gestión de versiones y publicación de paquetes
Sistema de compilación completo con andamiaje
Sistema de compilación de alto rendimiento
Caché de Compilación
No nativo (requiere integración)
Avanzado, local y remoto
Avanzado, local y remoto
Análisis del Grafo de Dependencias
Básico
Avanzado, con visualización
Avanzado, para orquestación de tareas
Generación de Código
No
Extensiva, a través de plugins y generadores
No
Curva de Aprendizaje
Baja
Moderada a Alta
Baja
Extensibilidad
Limitada
Alta (ecosistema de plugins)
Limitada (se integra con herramientas existentes)
Caso de Uso Ideal
Proyectos pequeños, publicación de paquetes
Grandes aplicaciones empresariales, microservicios
Proyectos que priorizan la velocidad de CI/CD y la simplicidad


1.2. Configuración del Espacio de Trabajo con Yarn y Turborepo

La estructura y configuración del monorepo están diseñadas para la simplicidad, la escalabilidad y la claridad.

1.2.1. Estructura de Directorios

Se adoptará una estructura plana y lógica. Dado que todos los paquetes de @worldlab son bibliotecas y no aplicaciones desplegables, se omite la distinción común apps/ y packages/ en favor de un único directorio packages/.5



worldlab-monorepo/
├── packages/
│   ├── generators/
│   │   ├── src/
│   │   └── package.json
│   ├── events/
│   │   ├── src/
│   │   └── package.json
│   └── physics/
│       ├── src/
│       └── package.json
├── package.json
├── yarn.lock
├── turbo.json
└── tsconfig.base.json



1.2.2. Archivos de Configuración Clave

package.json (Raíz): Este archivo es el centro de control del monorepo.
Se configurará para Yarn Workspaces, estableciendo "private": true para evitar la publicación accidental del repositorio raíz y definiendo el glob de los paquetes: "workspaces": ["packages/*"].7
Todas las dependencias de desarrollo compartidas (e.g., typescript, jest, eslint, prettier) se declararán aquí para garantizar una única versión en todo el proyecto, evitando conflictos y simplificando la gestión.7
package.json (Paquete): Cada paquete individual (e.g., packages/events/package.json) definirá su nombre (@worldlab/events), versión, scripts y dependencias. Las dependencias entre paquetes dentro del monorepo se especificarán utilizando el protocolo de espacio de trabajo ("workspace:*").4 Yarn resolverá esto a enlaces simbólicos locales, lo que significa que los cambios en un paquete están disponibles instantáneamente para sus dependientes sin necesidad de un paso de compilación intermedio.9
turbo.json (Configuración de Turborepo): Este archivo define el pipeline de tareas para todo el monorepo.
Se definirán tareas como build, test y lint.
Se configurarán las dependencias entre tareas. Por ejemplo, la tarea test de un paquete dependerá de la finalización de su propia tarea build y de la tarea build de sus dependencias internas.
Se especificarán las entradas (inputs) y salidas (outputs) para cada tarea, lo que permite a Turborepo determinar qué tareas se pueden omitir de forma segura gracias al almacenamiento en caché.2

JSON


// turbo.json
{
  "$schema": "https://turbo.build/schema.json",
  "pipeline": {
    "build": {
      "dependsOn": ["^build"],
      "outputs": ["dist/**"]
    },
    "test": {
      "dependsOn": ["build"],
      "inputs": ["src/**/*.ts", "test/**/*.ts"]
    },
    "lint": {
      "outputs":
    }
  }
}



1.3. Aplicación de la Calidad y Coherencia del Código

Para mantener un alto estándar de calidad en una base de código compartida, es imperativo contar con herramientas automatizadas y configuraciones centralizadas.
Configuración Centralizada: Se crearán archivos de configuración en la raíz del monorepo para ESLint (.eslintrc.js), Prettier (.prettierrc) y TypeScript (tsconfig.base.json). Cada paquete individual extenderá estas configuraciones base, permitiendo anulaciones menores específicas del paquete si es necesario, pero garantizando una base coherente para todo el proyecto.7
TypeScript Project References: Para optimizar el rendimiento del compilador de TypeScript y habilitar compilaciones incrementales, se utilizarán las referencias de proyecto (project references). El tsconfig.json de cada paquete referenciará a sus dependencias internas. Esto permite que el compilador de TypeScript (y, por extensión, Turborepo) solo recompile los paquetes que han cambiado o cuyos dependientes han cambiado, evitando un trabajo redundante y acelerando significativamente los tiempos de compilación en monorepos grandes.9

1.4. Estrategia de Scripting entre Paquetes y Pipeline de CI/CD

La ejecución de tareas en el monorepo se simplifica y acelera mediante el uso de la CLI de Turborepo.
Ejecución de Tareas: Los scripts en el package.json raíz invocarán a Turborepo (e.g., "test": "turbo run test"). Turborepo analizará el grafo de dependencias y ejecutará las tareas en el orden correcto, en paralelo siempre que sea posible, y utilizando su caché para omitir el trabajo ya realizado.1
Pipeline de CI/CD: El pipeline de integración continua (e.g., utilizando GitHub Actions) se vuelve notablemente simple. Después de un único paso de yarn install en la raíz, un comando como turbo run test ejecutará todas las pruebas necesarias de manera optimizada. De manera similar, turbo run build compilará todos los paquetes. Se recomienda encarecidamente la configuración de la caché remota de Turborepo, que permite compartir los artefactos de compilación y los resultados de las pruebas entre todos los miembros del equipo y las ejecuciones de CI, lo que resulta en reducciones drásticas de los tiempos de espera.

II. Especificación del Paquete Principal: @worldlab/generators

Este paquete constituye el núcleo creativo del motor, proporcionando un conjunto de herramientas para la generación procedural de contenido (PCG). Su arquitectura está diseñada para ser modular, extensible y de alto rendimiento, capaz de crear mundos de juego vastos, detallados y coherentes.

2.1. Visión General de la Arquitectura: Un Pipeline de Generación Conectable y Basado en Chunks

La filosofía central detrás de @worldlab/generators es tratar la generación de mundos no como una función monolítica, sino como un pipeline de transformaciones de datos componibles y discretas. Este enfoque se alinea con la naturaleza modular del monorepo y produce una arquitectura inherentemente comprobable y extensible.
Generación Basada en Chunks: Para soportar mundos efectivamente infinitos o de gran escala, toda la generación se basará en "chunks". Un chunk es un volumen discreto de espacio (e.g., un cubo de 32x32x32 metros). Los generadores operarán en un chunk a la vez, utilizando un enfoque determinista basado en una semilla global y las coordenadas del chunk. Esto garantiza que cualquier chunk pueda ser regenerado de manera idéntica en cualquier momento, una propiedad esencial para el streaming de mundos y la gestión eficiente de la memoria.12
Ruido Coherente para Transiciones sin Fisuras: La clave para lograr transiciones imperceptibles entre chunks adyacentes es el uso de funciones de "ruido coherente". Estas funciones, como Simplex Noise, producen un valor determinista para cualquier coordenada de entrada en el espacio del mundo. Esto significa que el valor en el borde de un chunk (e.g., en la coordenada x=31) será idéntico al valor en el borde del chunk adyacente (en la coordenada x=32, que corresponde a x=0 en el nuevo chunk). Esta coherencia matemática garantiza que los bordes del terreno se alineen perfectamente sin necesidad de algoritmos de suavizado o costura posteriores.13

2.2. Diseño de la API: La Interfaz Generator

La API del paquete se diseñará para ser clara, predecible y fácil de usar, promoviendo la consistencia en todas las implementaciones de generadores.15
Interfaz Generator: Se definirá una interfaz central que todos los pasos de generación deben implementar.
TypeScript
/**
 * Contexto que contiene todos los parámetros globales para una operación de generación.
 */
export interface GenerationContext {
  seed: number;
  chunkCoord: { x: number; y: number; z: number };
  chunkSize: { width: number; height: number; depth: number };
  // Otros parámetros globales como la configuración de octavas, frecuencia, etc.
}

/**
 * Interfaz genérica para un paso de generación que produce un tipo de datos T.
 */
export interface Generator<T> {
  generate(context: Generation-Context): T;
}


Configuración Declarativa: Los generadores se configurarán a través de objetos de opciones de JavaScript simples. Este enfoque facilita la serialización de las configuraciones del mundo, la creación de herramientas de edición visual y la escritura de pruebas unitarias.
API Pública: El paquete exportará una clase principal WorldGenerator que orquesta el pipeline completo. Además, se exportarán las clases de generadores individuales (e.g., SimplexNoiseGenerator, BiomeGenerator) y funciones de utilidad, permitiendo a los usuarios construir sus propios pipelines de generación personalizados.

2.3. Implementación Detallada


2.3.1. Generación de Terreno con Simplex Noise

La base de la mayoría de los mundos naturales es un mapa de alturas (heightmap) convincente.
Elección del Algoritmo: Se utilizará Simplex Noise en lugar del clásico Perlin Noise. Aunque ambos son tipos de ruido de gradiente, Simplex Noise presenta ventajas significativas. Su complejidad computacional escala mejor en dimensiones superiores (O(n2) frente a O(2n) de Perlin) y, lo que es más importante para la calidad visual, produce menos artefactos direccionales.16 El ruido de Perlin, debido a su base en una cuadrícula cúbica, puede generar patrones visuales a lo largo de los ejes y diagonales (45 y 90 grados), mientras que la base de simplex (triángulos en 2D, tetraedros en 3D) del ruido Simplex mitiga en gran medida este problema, resultando en un aspecto más orgánico y natural.18
Tabla 2: Comparación entre Perlin Noise y Simplex Noise
Métrica
Perlin Noise
Simplex Noise
Complejidad Computacional (n-dim)
O(2n)
O(n2)
Artefactos Visuales
Artefactos direccionales en ejes y diagonales
Significativamente reducidos, más isotrópico
Estructura de la Rejilla
Hipercubo (cuadrados, cubos)
Simplex (triángulos, tetraedros)
Escalado Dimensional
Lento en 4D y superior
Eficiente en dimensiones superiores
Caso de Uso Principal
Texturas 2D y 3D donde los artefactos no son críticos
Terrenos de alta calidad, texturas volumétricas

Implementación: Se creará un HeightmapGenerator que utilice una biblioteca de Simplex Noise de terceros. Este generador combinará múltiples "octavas" de ruido —capas de la misma función de ruido con frecuencias crecientes y amplitudes decrecientes— para crear un ruido fractal. Este proceso superpone detalles finos sobre características a gran escala, una técnica fundamental para imitar la apariencia de paisajes naturales como montañas y costas.20 La salida será una matriz 2D de valores de altura para un chunk determinado.

2.3.2. Generación de Biomas a través de Mapas Multicapa

La creación de biomas diversos y creíbles se logrará mediante un pipeline que superpone múltiples mapas de datos, un enfoque que refleja los procesos naturales.
Modelo del Diagrama de Whittaker: La lógica de distribución de biomas se basará en el modelo de biomas de Whittaker, un principio ecológico que clasifica los biomas en función de dos variables principales: la temperatura media anual y la precipitación media anual.22
Pipeline de Generación de Biomas:
Mapa de Elevación: Se genera el mapa de alturas base utilizando el HeightmapGenerator.
Mapa de Temperatura: Se genera un mapa de temperatura base utilizando otra instancia de Simplex Noise, típicamente con una frecuencia mucho más baja para crear zonas climáticas amplias.
Mapa de Humedad: De manera similar, se genera un mapa de humedad base con su propia configuración de ruido.
Ajuste y Muestreo: Un BiomeGenerator procesa cada punto del chunk. Muestrea el valor de los tres mapas. A continuación, ajusta la temperatura base en función de la elevación (una mayor altitud resulta en una temperatura más baja), simulando el gradiente adiabático.22
Clasificación: Finalmente, utiliza una tabla de consulta 2D (una implementación programática del diagrama de Whittaker) para determinar el tipo de bioma final (e.g., Tundra, Bosque Boreal, Desierto) basándose en los valores finales de temperatura y humedad.23
Este enfoque de pipeline de transformación de datos es fundamental. Comienza con datos brutos de ruido y los refina progresivamente a través de pasos lógicos y componibles, cada uno de los cuales puede ser probado y ajustado de forma independiente. Esta modularidad es una ventaja arquitectónica significativa sobre los enfoques monolíticos.

2.3.3. Gestión de Chunks sin Fisuras y Nivel de Detalle (LOD)

Generación Determinista: La clase principal WorldGenerator tomará una coordenada de chunk (e.g., {x: 1, y: 0, z: 5}) y la semilla global como entrada. Todos los generadores en el pipeline utilizarán estos valores para producir de manera determinista los datos exactos para ese chunk específico.
Nivel de Detalle (LOD): Para renderizar mundos vastos de manera eficiente, los chunks distantes deben tener una menor complejidad geométrica. El WorldGenerator soportará la generación de versiones de menor resolución de los datos de un chunk. Una técnica eficaz es simplemente muestrear las funciones de ruido subyacentes con una frecuencia más baja para los chunks de LOD más bajos.26
Prevención de Grietas (Stitching): Un desafío común con los sistemas de LOD basados en chunks es la aparición de grietas visuales en los bordes entre chunks de diferentes niveles de detalle. Para resolver esto, el generador debe proporcionar los datos necesarios para que el sistema de renderizado realice la "costura" (stitching). Un método consiste en que cada chunk genere una "falda" (skirt) de un vóxel de ancho alrededor de su perímetro, cuyos vértices se alinean con los del vecino de menor LOD. Una técnica más avanzada es el "morphing" de vértices, donde los vértices en el borde se interpolan suavemente entre su posición de alto LOD y su posición de bajo LOD correspondiente, creando una transición visualmente imperceptible.28 El paquete
@worldlab/generators se centrará en producir los datos brutos (e.g., mapas de altura para múltiples LODs) que permitan al sistema de renderizado implementar estas técnicas.

III. Especificación del Paquete Principal: @worldlab/events

Este paquete proporciona el sistema nervioso central para el motor, permitiendo una comunicación desacoplada y eficiente entre todos los demás sistemas. Su diseño debe priorizar la seguridad de tipos, el rendimiento y una API intuitiva.

3.1. Visión General de la Arquitectura: Un Bus de Eventos Desacoplado y con Seguridad de Tipos

Patrón Publicar-Suscribir (Pub/Sub): El núcleo del paquete será una implementación del patrón de diseño publicar-suscribir. Los sistemas pueden "suscribirse" a tipos de eventos específicos, y otros sistemas pueden "publicar" (o emitir) eventos sin tener conocimiento directo de los suscriptores. Este desacoplamiento es fundamental para una arquitectura modular y mantenible.30
Implementación Singleton: Para garantizar un único canal de comunicación global en toda la aplicación, el EventBus se implementará como un singleton. Esto permite que cualquier parte del motor acceda a la misma instancia del bus para enviar y recibir mensajes, evitando la necesidad de pasar referencias del bus a través de múltiples capas de la aplicación.30
Seguridad de Tipos Estática: Un pilar del diseño será el uso avanzado de los genéricos de TypeScript para garantizar la seguridad de tipos estática. Al definir un mapa central de tipos de eventos y sus correspondientes cargas útiles (payloads), el compilador de TypeScript puede verificar en tiempo de compilación que los datos enviados con un evento coincidan con el tipo que los suscriptores esperan recibir. Esto previene una clase entera de errores en tiempo de ejecución.30

3.2. Diseño de la API

La API del EventBus será minimalista, clara y fuertemente tipada para una experiencia de desarrollador óptima.

TypeScript


// packages/events/src/types.ts

// Un mapa central que define todos los eventos del sistema y sus cargas útiles.
// Esta es la única fuente de verdad para la estructura de los eventos.
export type EventMap = {
  'entity:spawned': { entityId: number; archetype: string };
  'entity:destroyed': { entityId: number };
  'collision:enter': { entityA: number; entityB: number; contactPoint: { x: number; y: number; z: number } };
  'llm:responseReceived': { requestId: string; responseText: string; isPlausible: boolean };
  'world:chunkGenerated': { chunkCoord: { x: number; y: number; z: number } };
};

// packages/events/src/EventBus.ts

export class EventBus {
  /**
   * Obtiene la instancia singleton del EventBus.
   */
  public static getInstance(): EventBus;

  /**
   * Se suscribe a un tipo de evento.
   * @param eventName El nombre del evento al que suscribirse.
   * @param listener La función de devolución de llamada que se ejecutará cuando se emita el evento.
   */
  public on<K extends keyof EventMap>(eventName: K, listener: (payload: EventMap[K]) => void): void;

  /**
   * Cancela la suscripción a un tipo de evento.
   * @param eventName El nombre del evento del que cancelar la suscripción.
   * @param listener La función de devolución de llamada exacta que se utilizó para suscribirse.
   */
  public off<K extends keyof EventMap>(eventName: K, listener: (payload: EventMap[K]) => void): void;

  /**
   * Emite un evento, notificando a todos los suscriptores.
   * @param eventName El nombre del evento a emitir.
   * @param payload Los datos asociados con el evento.
   */
  public emit<K extends keyof EventMap>(eventName: K, payload: EventMap[K]): void;
}


Este diseño, utilizando un tipo mapeado (EventMap), proporciona autocompletado y verificación de tipos completos tanto al emitir como al escuchar eventos, lo que reduce drásticamente los errores comunes.32

3.3. Implementación Detallada: Un EventBus Singleton

La implementación interna utilizará un constructor privado y un método estático getInstance para hacer cumplir el patrón singleton.30 Un mapa (
Map<keyof EventMap, Array<(payload: any) => void>>) almacenará los arrays de funciones de escucha para cada nombre de evento. El método emit recuperará el array de escuchas para un evento dado y las invocará secuencialmente con la carga útil proporcionada.

3.4. Aplicación Avanzada: Arquitectura para Eventos de Juego Impulsados por LLM

La integración de tecnologías modernas como los Modelos de Lenguaje Grandes (LLM) impone nuevos requisitos a la arquitectura de eventos de un motor de juego.
El Desafío de la Asincronía: La inferencia de un LLM es una operación inherentemente lenta (puede tardar de segundos a minutos) y asíncrona. Una arquitectura tradicional de solicitud-respuesta bloquearía el hilo principal del juego, congelando la experiencia del usuario mientras se espera la respuesta del LLM. Una Arquitectura Dirigida por Eventos (EDA) no es solo una opción, sino un requisito fundamental para mantener la capacidad de respuesta de la aplicación.33
Pipeline de LLM Dirigido por Eventos:
Una acción en el juego (e.g., un jugador habla con un NPC) hace que un sistema (InteractionSystem) emita un evento llm:prompt:submit con el texto del jugador y el contexto relevante.
Un LLMSystem desacoplado escucha este evento. Al recibirlo, formatea el prompt y lo envía a una API de LLM externa. El juego continúa ejecutándose sin interrupciones.
Cuando la API del LLM finalmente responde, el LLMSystem realiza una validación de plausibilidad inicial y luego emite un evento llm:response:received con el texto de la respuesta y un ID de solicitud para correlación.
Otros sistemas, como DialogueSystem o QuestSystem, están suscritos a llm:response:received. Al recibir la respuesta, actualizan el estado del juego, mostrando el diálogo del NPC o activando un nuevo objetivo de misión.
Prompting Basado en Inferencia de Estado: Para crear interacciones con LLM más robustas y gobernadas por reglas, se puede adoptar un enfoque de máquina de estados. En lugar de simplemente enviar texto, el prompt enviado al LLM incluirá el estado actual del juego (e.g., "estado: negociando_precio", "estado: en_combate"). Se le pide al LLM no solo que genere una respuesta de diálogo, sino también que infiera y sugiera la transición al siguiente estado.35 La carga útil del evento
llm:response:received incluiría entonces tanto el texto de la respuesta como la transición de estado propuesta (e.g., "siguiente_estado": "confirmando_compra"). Un GameStateSystem sería responsable de validar y aplicar esta transición de estado. Este patrón transforma al LLM de un simple generador de texto a un participante activo en la lógica de la máquina de estados del juego.36
La integración de servicios externos asíncronos como los LLM obliga a la arquitectura de eventos del motor a evolucionar. Ya no es suficiente un simple despachador de eventos síncrono. El sistema debe adoptar principios de arquitecturas distribuidas robustas, como la idempotencia (para manejar reintentos de eventos de forma segura), el versionado de eventos (para gestionar cambios en los modelos de LLM y sus salidas) y patrones como el "circuit breaker" para manejar fallos de la API de forma elegante.33
@worldlab/events debe ser diseñado como la base para esta capa de comunicación asíncrona y resiliente.

IV. Especificación del Paquete Principal: @worldlab/physics

Este paquete tiene como objetivo aislar la complejidad de la simulación física del resto del motor, proporcionando una API limpia, de alto nivel y agnóstica al motor subyacente para interactuar con el mundo físico.

4.1. Visión General de la Arquitectura: Una Capa de Abstracción sobre cannon-es

Elección del Motor Físico: Se ha seleccionado cannon-es como motor físico inicial. Es una bifurcación moderna y mantenida del popular cannon.js, reescrita en TypeScript. Al ser JavaScript puro, se integra sin problemas en el ecosistema Node.js/navegador. Ofrece un conjunto de características robusto para muchos tipos de juegos 3D, incluyendo dinámicas de cuerpo rígido, una variedad de formas de colisión (esfera, caja, plano, poliedro convexo, campo de altura), y restricciones.38
Capa de Abstracción (Facade): Una decisión arquitectónica crítica es no exponer las API de cannon-es directamente al resto del motor de juego. En su lugar, @worldlab/physics actuará como una capa de abstracción o fachada (Facade Pattern). El propósito de esta capa es doble:
Simplificar la API: Proporcionar una API más simple y orientada a tareas comunes de juego, ocultando los detalles de implementación de cannon-es.
Intercambiabilidad del Motor: Esta es la ventaja más significativa. Al desacoplar la lógica del juego de un motor físico específico, se vuelve posible en el futuro reemplazar cannon-es por una alternativa más performante (e.g., Rapier, o una versión de PhysX compilada a WebAssembly) con cambios mínimos en el resto de la base de código del motor.

4.2. Diseño de la API

La API pública se diseñará en torno a conceptos de juego familiares, utilizando identificadores opacos (handles) en lugar de referencias directas a los objetos internos de cannon-es para hacer cumplir la abstracción.

TypeScript


// packages/physics/src/types.ts
export type BodyHandle = number;
export type ConstraintHandle = number;

export interface BodyOptions {
  entityId: number;
  mass: number; // 0 para cuerpos estáticos
  position: { x: number; y: number; z: number };
  shape: { type: 'sphere'; radius: number } | { type: 'box'; halfExtents: { x: number; y: number; z: number } };
  //... otras propiedades como fricción, restitución, etc.
}

// packages/physics/src/PhysicsWorld.ts
export class PhysicsWorld {
  constructor(gravity: { x: number; y: number; z: number });

  /**
   * Avanza la simulación física en un paso de tiempo fijo.
   * @param deltaTime El tiempo transcurrido desde el último fotograma.
   */
  public step(deltaTime: number): void;

  /**
   * Añade un cuerpo rígido a la simulación.
   * @param options Las opciones para crear el cuerpo.
   * @returns Un handle para el cuerpo recién creado.
   */
  public addBody(options: BodyOptions): BodyHandle;

  /**
   * Elimina un cuerpo rígido de la simulación.
   * @param handle El handle del cuerpo a eliminar.
   */
  public removeBody(handle: BodyHandle): void;

  //... métodos para raycasting, restricciones (constraints), etc.
}



4.3. Implementación Detallada


4.3.1. Gestión del Mundo y Avance de la Simulación

La clase PhysicsWorld encapsulará una instancia de CANNON.World. Su método step no llamará directamente a world.step(deltaTime), sino a world.fixedStep(). Este método gestiona internamente el tiempo para garantizar que la simulación se actualice a una frecuencia fija (e.g., 60 Hz), independientemente de la tasa de fotogramas del renderizado. Esto es crucial para la estabilidad y la reproducibilidad de las simulaciones físicas.39

4.3.2. Mapeo de Cuerpos Físicos a Entidades ECS

El desafío central de la integración es conectar el paradigma orientado a objetos de cannon-es con el mundo orientado a datos del ECS. @worldlab/physics mantendrá internamente un mapa que asocia el ID de una entidad ECS con su cuerpo físico correspondiente en cannon-es: Map<EntityID, CANNON.Body>. Cuando se añade un cuerpo a través de la API addBody, se crea el CANNON.Body, se almacena en este mapa utilizando el entityId proporcionado, y se devuelve un handle que puede ser el mismo entityId.

4.3.3. Manejo de Eventos de Colisión

cannon-es proporciona eventos para detectar colisiones. La clase PhysicsWorld se suscribirá a estos eventos. Cuando se detecta una colisión entre dos objetos CANNON.Body, el sistema realizará los siguientes pasos:
Buscará en sus mapas internos los IDs de las entidades ECS correspondientes a los dos cuerpos involucrados.
Recopilará datos relevantes de la colisión (e.g., punto de contacto, normal).
Utilizará el EventBus de @worldlab/events para emitir un evento fuertemente tipado, como collision:enter.
La carga útil de este evento contendrá los IDs de las dos entidades y los datos de la colisión.
Este enfoque desacopla completamente el sistema de física de cualquier sistema de lógica de juego que necesite reaccionar a las colisiones (e.g., un sistema de salud que reduce la vida al recibir daño, un sistema de sonido que reproduce un efecto de impacto).
La arquitectura resultante trata al motor de física como una "caja negra" de cálculo de estado. Se establece un flujo de datos unidireccional claro: los sistemas de lógica de juego modifican los componentes de datos en el ECS (la fuente de verdad); un sistema de sincronización lee estos componentes y actualiza el estado del mundo de cannon-es; se avanza la simulación; y finalmente, otro sistema de sincronización escribe los nuevos estados de los cuerpos físicos de vuelta a los componentes del ECS. Este patrón (ECS -> Física -> ECS) previene dependencias circulares, establece una única fuente de verdad para el estado del juego y crea un flujo de datos claro y depurable, evitando el "código espagueti" arquitectónico.

V. Integración Unificada con un Sistema de Componentes de Entidad (ECS)

Esta sección sintetiza los tres paquetes principales, demostrando cómo operan de manera cohesiva dentro de una arquitectura ECS unificada. El ECS no es simplemente un patrón de organización de código; es la columna vertebral arquitectónica que permite que todos los demás módulos interoperen sin problemas.

5.1. Principios Fundamentales de ECS para @worldlab

Se adoptará un enfoque estricto de diseño orientado a datos, que maximiza la eficiencia de la caché y la claridad arquitectónica.40
Entidades (Entities): Son simplemente identificadores únicos (e.g., un número entero). No contienen datos ni lógica.31
Componentes (Components): Son estructuras de datos puras (Plain Old Data - PODs), similares a structs. Contienen el estado de un aspecto de una entidad (e.g., su posición, su salud). No contienen lógica ni métodos.42
Sistemas (Systems): Contienen toda la lógica del juego. Los sistemas operan sobre conjuntos de entidades que poseen una combinación específica de componentes.31
Este enfoque de "datos aquí, lógica allá" es el que permite el alto rendimiento y la flexibilidad del patrón ECS.

5.2. Diseño de Componentes para los Paquetes @worldlab

Los componentes son el puente entre los paquetes del motor y el estado del mundo del juego.
Componentes de @worldlab/generators:
TerrainChunkComponent: Almacena los datos generados para un chunk de terreno, como el objeto de malla (mesh), el mapa de biomas y los datos de colisión física.
ProceduralTagComponent: Un componente de etiqueta (sin datos) que marca a una entidad como generada proceduralmente. Puede incluir metadatos opcionales como la semilla utilizada.
Componentes de @worldlab/events:
EventListenerComponent: Permite que las entidades reaccionen a eventos de forma individual. Almacena un mapa de tipos de eventos y las funciones de devolución de llamada que deben ejecutarse.
EventTargetComponent: Un componente de datos que contiene una cola de eventos dirigidos específicamente a esta entidad, para ser procesados por un EntityEventSystem.
Componentes de @worldlab/physics:
TransformComponent: La única fuente de verdad para el estado espacial de una entidad. Contiene position, rotation y scale.40
PhysicsBodyComponent: Contiene los parámetros de configuración para un cuerpo físico (masa, fricción, restitución, tipo de forma) y el BodyHandle que lo vincula con el cuerpo real en el mundo de @worldlab/physics.
CollisionEventComponent: Un componente transitorio que se añade a una entidad cuando ocurre una colisión. Contiene datos sobre la colisión (e.g., la otra entidad, la fuerza del impacto). Es procesado por los sistemas de lógica de juego y luego eliminado al final del fotograma.

5.3. Diseño de Sistemas y Orden de Ejecución

El orden en que se ejecutan los sistemas define el bucle de un solo fotograma del juego. Un orden lógico y predecible es crucial para evitar errores sutiles y comportamientos inesperados.

5.3.1. Pipeline del Fotograma de Juego

InputSystem: Captura la entrada del usuario (teclado, ratón, etc.) y la traduce en componentes de "intención" (e.g., MoveIntentComponent, ActionIntentComponent).
GameLogicSystems: Un grupo de sistemas (e.g., PlayerControlSystem, AISystem) que leen los componentes de intención y modifican el estado de otros componentes. Por ejemplo, PlayerControlSystem podría leer un MoveIntentComponent y actualizar la propiedad de velocidad en el PhysicsBodyComponent de la entidad del jugador.
PrePhysicsSyncSystem: Itera sobre todas las entidades con TransformComponent y PhysicsBodyComponent. Lee los datos de estos componentes y los utiliza para actualizar el estado de los cuerpos correspondientes en el mundo de @worldlab/physics. Este es el paso "ECS -> Física".
PhysicsSystem: Realiza una única llamada a physicsWorld.step(deltaTime). Este sistema también es responsable de escuchar los eventos de colisión del mundo físico y, como respuesta, añadir CollisionEventComponent a las entidades involucradas.
PostPhysicsWritebackSystem: Itera sobre todos los cuerpos en el mundo físico, lee sus estados actualizados (posición, rotación) y los escribe de nuevo en los TransformComponent de las entidades ECS correspondientes. Este es el paso "Física -> ECS".
CollisionLogicSystem: Itera sobre todas las entidades que tienen un CollisionEventComponent. Aquí es donde se ejecuta la lógica de juego real en respuesta a las colisiones (e.g., reducir la salud, reproducir un sonido).
EventDispatchSystem: Procesa la cola de eventos globales de @worldlab/events, activando la lógica correspondiente.
GeneratorSystem: Comprueba la posición del jugador u otros criterios para determinar si se deben generar nuevos chunks del mundo. Si es necesario, invoca a @worldlab/generators y crea nuevas entidades con TerrainChunkComponent y otros componentes relevantes.
RenderSystem: Itera sobre todas las entidades con componentes renderizables (e.g., TerrainChunkComponent, MeshComponent) y un TransformComponent, y las dibuja en la pantalla.
CleanupSystem: Elimina todos los componentes transitorios del fotograma, como MoveIntentComponent y CollisionEventComponent, preparando el mundo para el siguiente ciclo.
Este pipeline estructurado es la manifestación del ECS como el gran unificador. Los paquetes (generators, physics, events) proporcionan las capacidades, pero son los sistemas, orquestados en un orden definido, los que utilizan estas capacidades para dar vida al mundo del juego. El ECS actúa como la capa de datos común que permite a estos dominios dispares interoperar de manera desacoplada.

5.4. Diagrama de Flujo de Datos

Para visualizar esta interacción, se incluiría un diagrama de flujo de datos que muestre cómo los datos fluyen desde los componentes, a través de los sistemas (incluida la "caja negra" del motor de física), y de vuelta a los componentes, destacando el flujo unidireccional y la ausencia de dependencias directas entre los sistemas de lógica de juego.

VI. Una Estrategia de Pruebas Completa y Multicapa

Un motor de calidad profesional exige una estrategia de pruebas igualmente profesional. Esta sección detalla un enfoque de múltiples capas para garantizar la fiabilidad, corrección y rendimiento del ecosistema @worldlab. La estrategia de pruebas no es un añadido, sino un reflejo directo de los desafíos arquitectónicos inherentes a cada paquete.

6.1. Pruebas Unitarias

Alcance: Probar funciones, clases y módulos individuales de forma aislada. El framework de elección será Jest.
@worldlab/generators: Las pruebas unitarias se centrarán en los generadores individuales. Se utilizará una semilla fija para las funciones de ruido, lo que garantiza una salida determinista y repetible. Se pueden crear aserciones sobre las propiedades de la salida (e.g., que los valores de un mapa de alturas estén dentro de un rango esperado).
@worldlab/events: Se probará la lógica interna del EventBus: verificar que los suscriptores se añaden correctamente, que se invocan al emitir un evento y que se eliminan correctamente con el método off.
@worldlab/physics: Las pruebas unitarias se centrarán en la capa de abstracción. Se utilizará Jest para simular (mock) la biblioteca cannon-es subyacente y verificar que las llamadas a la API de @worldlab/physics se traducen en las llamadas correctas a la API de cannon-es con los parámetros adecuados.

6.2. Pruebas de Integración

Alcance: Probar la interacción entre los paquetes y entre los sistemas dentro del ECS.
Comunicación entre Paquetes: Se escribirán pruebas que validen el flujo de eventos a través del sistema. Por ejemplo, una prueba podría simular una colisión en el PhysicsSystem, verificar que se emite un evento collision:enter a través de @worldlab/events, y confirmar que un DamageSystem simulado reacciona correctamente a ese evento.44
Validación de la Simulación Física: Las simulaciones físicas, aunque complejas, deben ser deterministas. Se crearán escenas de prueba con configuraciones específicas (e.g., una esfera en la parte superior de un plano inclinado). La simulación se ejecutará durante un número fijo de pasos con un deltaTime fijo. Al final, se afirmará que la posición y la velocidad finales de la esfera están dentro de una pequeña tolerancia de los valores esperados calculados analíticamente. Esto valida la corrección de la integración física.45 Además, se probarán las restricciones (
constraints) para asegurar que limitan el movimiento de los cuerpos como se espera, incluyendo pruebas que verifiquen si los límites de una restricción se están excediendo.47
Validación de la Generación Procedural: La naturaleza pseudoaleatoria de la PCG requiere técnicas de prueba especializadas.
Pruebas de Valor de Oro (Golden Value Testing): Para una semilla y un conjunto de parámetros dados, se genera un chunk y sus datos de salida (e.g., el mapa de alturas) se guardan en un archivo "de oro". Las ejecuciones de prueba posteriores generarán el chunk con la misma semilla y compararán la salida con el archivo guardado. Cualquier diferencia indica una regresión en el algoritmo de generación.
Pruebas de Fuzzing y Validación de Invariantes: Se crearán pruebas que ejecuten el generador con un gran número de semillas y parámetros aleatorios. En lugar de comprobar valores exactos, estas pruebas ejecutarán validadores sobre la salida para comprobar invariantes y propiedades deseables. Por ejemplo: "¿Están todos los valores del mapa de alturas dentro del rango ``?", "¿Hay algún valor NaN o Infinity?", "¿Son accesibles todas las áreas generadas desde el punto de inicio?". Este enfoque es extremadamente eficaz para descubrir casos límite y errores inesperados que las pruebas deterministas pasarían por alto.49

6.3. Pruebas de Extremo a Extremo (E2E)

Alcance: Probar un bucle de juego completo y simulado en un entorno sin cabeza (headless).
Metodología: Una prueba E2E configurará un mundo ECS completo con todos los sistemas relevantes en su orden de ejecución correcto. Simulará eventos de entrada a lo largo de varios fotogramas (e.g., emitir un evento de "mover hacia adelante" durante 10 fotogramas). Al final del bucle, se realizarán aserciones sobre el estado final del mundo ECS (e.g., "¿Se ha movido la entidad del jugador a la posición esperada?", "¿Se emitió un evento collision:enter cuando el jugador chocó contra un muro?").

6.4. Configuración de CI para Pruebas Selectivas

El pipeline de CI se configurará para aprovechar al máximo las capacidades de Turborepo. El paso de prueba utilizará un comando como turbo run test --filter="[...changed]". Esta sintaxis instruye a Turborepo para que ejecute únicamente los conjuntos de pruebas de los paquetes que han sido modificados en una solicitud de extracción (pull request) determinada, así como los de cualquier paquete que dependa de ellos. Esta estrategia de pruebas selectivas reduce drásticamente los tiempos de espera de la CI, manteniendo un ciclo de retroalimentación rápido y mejorando la productividad general del equipo de desarrollo.44
Fuentes citadas
nx vs turbo vs lerna vs @microsoft/rush | Monorepo Management ..., acceso: septiembre 14, 2025, https://npm-compare.com/nx,turbo,lerna,@microsoft/rush
Mono Repo; Turbo Repo vs Nx vs Lerna and Why Turbo? | by Vivi - Medium, acceso: septiembre 14, 2025, https://medium.com/@givvemeee/mono-repo-turbo-repo-vs-nx-vs-lerna-and-why-turbo-4616be2aadb3
Lerna and Nx, acceso: septiembre 14, 2025, https://lerna.js.org/docs/lerna-and-nx
Workspaces | Yarn, acceso: septiembre 14, 2025, https://classic.yarnpkg.com/lang/en/docs/workspaces/
Monorepos: A Comprehensive Guide with Examples | by Md Julakadar - Medium, acceso: septiembre 14, 2025, https://medium.com/@julakadaredrishi/monorepos-a-comprehensive-guide-with-examples-63202cfab711
How do you structure your "shared" internal packages in a monorepo? : r/golang - Reddit, acceso: septiembre 14, 2025, https://www.reddit.com/r/golang/comments/1m0h50w/how_do_you_structure_your_shared_internal/
Building and Managing a Micro-Frontend Monorepo with Yarn ..., acceso: septiembre 14, 2025, https://medium.com/@asashish999/building-and-managing-a-micro-frontend-monorepo-with-yarn-workspaces-53e58bc03413
How to Set Up a Monorepo Using Yarn Workspaces | Full Guide - Deuex Solutions, acceso: septiembre 14, 2025, https://deuexsolutions.com/blog/monorepo-using-yarn-workspaces-a-complete-guide
Live types in a TypeScript monorepo - Colin McDonnell, acceso: septiembre 14, 2025, https://colinhacks.com/essays/live-types-typescript-monorepo
TypeScript Monorepos Done Right! - YouTube, acceso: septiembre 14, 2025, https://www.youtube.com/watch?v=D9D8KNffyBk
Resources for Monorepo Best Practices : r/node - Reddit, acceso: septiembre 14, 2025, https://www.reddit.com/r/node/comments/1i0m2od/resources_for_monorepo_best_practices/
Chunk-based procedural generation to my game! Name and Steam page in comments : r/godot - Reddit, acceso: septiembre 14, 2025, https://www.reddit.com/r/godot/comments/1hmgeq9/chunkbased_procedural_generation_to_my_game_name/
Chunk based world generation : r/proceduralgeneration - Reddit, acceso: septiembre 14, 2025, https://www.reddit.com/r/proceduralgeneration/comments/2zjp51/chunk_based_world_generation/
Matching a chunk of procedurally generated world to a chunk of other world - Game Development Stack Exchange, acceso: septiembre 14, 2025, https://gamedev.stackexchange.com/questions/108942/matching-a-chunk-of-procedurally-generated-world-to-a-chunk-of-other-world
API design tips for libraries - André Staltz, acceso: septiembre 14, 2025, https://staltz.com/api-design-tips-for-libraries
Perlin noise - Wikipedia, acceso: septiembre 14, 2025, https://en.wikipedia.org/wiki/Perlin_noise
Simplex noise vs Perlin noise - Stack Overflow, acceso: septiembre 14, 2025, https://stackoverflow.com/questions/6439350/simplex-noise-vs-perlin-noise
Differences in different types of noise? : r/proceduralgeneration - Reddit, acceso: septiembre 14, 2025, https://www.reddit.com/r/proceduralgeneration/comments/1c50n3e/differences_in_different_types_of_noise/
Generating biomes using the "zoom out" approach : r/proceduralgeneration - Reddit, acceso: septiembre 14, 2025, https://www.reddit.com/r/proceduralgeneration/comments/fgdj6m/generating_biomes_using_the_zoom_out_approach/
Procedural terrain generation with style transfer - arXiv, acceso: septiembre 14, 2025, https://arxiv.org/html/2403.08782v1
Procedurally Generating Terrain, acceso: septiembre 14, 2025, https://micsymposium.org/mics_2011_proceedings/mics2011_submission_30.pdf
Resources or Methods for Biome Generation? : r/proceduralgeneration, acceso: septiembre 14, 2025, https://www.reddit.com/r/proceduralgeneration/comments/7natln/resources_or_methods_for_biome_generation/
Procedurally Generating Wrapping World Maps in Unity C# – Part 4 ..., acceso: septiembre 14, 2025, http://www.jgallant.com/procedurally-generating-wrapping-world-maps-in-unity-csharp-part-4/
Biomes generation and rendering - Fantasy Maps for fun and glory - WordPress.com, acceso: septiembre 14, 2025, https://azgaar.wordpress.com/2017/06/30/biomes-generation-and-rendering/
Confused on how to implement biomes : r/proceduralgeneration - Reddit, acceso: septiembre 14, 2025, https://www.reddit.com/r/proceduralgeneration/comments/7yrh9c/confused_on_how_to_implement_biomes/
Chunked LOD split by distance - Game Development Stack Exchange, acceso: septiembre 14, 2025, https://gamedev.stackexchange.com/questions/177287/chunked-lod-split-by-distance
Rendering Massive Terrains using Chunked Level of, acceso: septiembre 14, 2025, https://www.classes.cs.uchicago.edu/archive/2015/fall/23700-1/final-project/chunked-lod.pdf
Voxels and Seamless LOD Transitions - dexyfex.com, acceso: septiembre 14, 2025, https://dexyfex.com/2016/07/14/voxels-and-seamless-lod-transitions/
How to generate Continuous Levels Of Detail for a Chunked Terrain (CLOD, Geomorphing)? : r/VoxelGameDev - Reddit, acceso: septiembre 14, 2025, https://www.reddit.com/r/VoxelGameDev/comments/5uzics/how_to_generate_continuous_levels_of_detail_for_a/
How to Implement an Event Bus in TypeScript - This Dot Labs, acceso: septiembre 14, 2025, https://www.thisdot.co/blog/how-to-implement-an-event-bus-in-typescript
Entity component system - Wikipedia, acceso: septiembre 14, 2025, https://en.wikipedia.org/wiki/Entity_component_system
How to build an in-memory Message Bus in TypeScript - Event-Driven.io, acceso: septiembre 14, 2025, https://event-driven.io/en/inmemory_message_bus_in_typescript/
Event-Driven Architecture in the AI Era: Patterns, Practices, and User ..., acceso: septiembre 14, 2025, https://medium.com/@abhilasha4042/event-driven-architecture-in-the-ai-era-patterns-practices-and-user-experience-a6db128f29ab
Designing Event-Driven Pipelines for LLM Automation - Newline.co, acceso: septiembre 14, 2025, https://www.newline.co/@zaoyang/designing-event-driven-pipelines-for-llm-automation--0efcc46e
State-Inference-Based Prompting for Natural Language ... - arXiv, acceso: septiembre 14, 2025, https://arxiv.org/pdf/2507.07203
State · Design Patterns Revisited - Game Programming Patterns, acceso: septiembre 14, 2025, https://gameprogrammingpatterns.com/state.html
AI - State Machines, acceso: septiembre 14, 2025, https://research.ncl.ac.uk/game/mastersdegree/gametechnologies/aitutorials/1state-basedai/AI%20-%20State%20Machines.pdf
Cannon.js - Wikipedia, acceso: septiembre 14, 2025, https://en.wikipedia.org/wiki/Cannon.js
cannon-es - GitHub Pages, acceso: septiembre 14, 2025, https://pmndrs.github.io/cannon-es/docs/
A Simple Entity Component System (ECS) [C++] - Austin Morlan, acceso: septiembre 14, 2025, https://austinmorlan.com/posts/entity_component_system/
Entity Component system (ECS) engine structure : r/gamedev - Reddit, acceso: septiembre 14, 2025, https://www.reddit.com/r/gamedev/comments/5afw8x/entity_component_system_ecs_engine_structure/
ECS 1: Inheritance vs Composition and ECS Background ..., acceso: septiembre 14, 2025, https://leatherbee.org/index.php/2019/09/12/ecs-1-inheritance-vs-composition-and-ecs-background/
Entity Component System - an old new thing - DEV Community, acceso: septiembre 14, 2025, https://dev.to/kspeakman/entity-component-system-an-old-new-thing-3224
Testing strategies for monorepos - Graphite, acceso: septiembre 14, 2025, https://graphite.dev/guides/testing-strategies-for-monorepos
JavaScript physics simulation | Generative AI on Vertex AI - Google Cloud, acceso: septiembre 14, 2025, https://cloud.google.com/vertex-ai/generative-ai/docs/prompt-gallery/samples/code_javascript_physics_simulation
myPhysicsLab Home Page, acceso: septiembre 14, 2025, https://www.myphysicslab.com/
Point to Point Constraints - Three.js Tutorials - SBCODE Tutorials, acceso: septiembre 14, 2025, https://sbcode.net/threejs/physics-p2p-constraints/
javascript - CANNON.js: check if a body is being constrained - Stack ..., acceso: septiembre 14, 2025, https://stackoverflow.com/questions/32216811/cannon-js-check-if-a-body-is-being-constrained
Towards Fuzz Testing a Procedurally-Generated ... - erik fredericks, acceso: septiembre 14, 2025, https://efredericks.github.io/publications/fredericks2024ASEENCS.pdf
